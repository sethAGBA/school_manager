# üß† Documentation Algorithme - Logique de g√©n√©ration d'emploi du temps

## Vue d'ensemble

L'algorithme impl√©ment√© est un **algorithme glouton avec backtracking** et fonction d'√©valuation multi-crit√®res. C'est une approche pragmatique qui √©quilibre performance et qualit√© des r√©sultats.

## üìä Flux de l'algorithme

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. Pr√©paration des donn√©es             ‚îÇ
‚îÇ     - Cr√©ation de tous les cours        ‚îÇ
‚îÇ     - Calcul du nombre de s√©ances       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  2. Tri par priorit√©                    ‚îÇ
‚îÇ     - Contraintes les plus restrictives ‚îÇ
‚îÇ     - Professeurs avec le plus de cours ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  3. Placement s√©quentiel                ‚îÇ
‚îÇ     Pour chaque cours :                 ‚îÇ
‚îÇ     ‚îú‚îÄ Trouver cr√©neaux valides         ‚îÇ
‚îÇ     ‚îú‚îÄ √âvaluer chaque cr√©neau           ‚îÇ
‚îÇ     ‚îú‚îÄ Choisir le meilleur              ‚îÇ
‚îÇ     ‚îî‚îÄ Attribuer une salle              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
             ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  4. √âvaluation globale                  ‚îÇ
‚îÇ     - Calcul du score final             ‚îÇ
‚îÇ     - V√©rification contraintes          ‚îÇ
‚îÇ     - Statistiques                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üîç √âtape 1 : Pr√©paration des donn√©es

### Calcul du nombre de s√©ances

Pour chaque mati√®re, on calcule le nombre de cours n√©cessaires :

```dart
nombreSeances = (volumeHoraireHebdo √ó 60) √∑ dureeSceance

Exemple :
- Math√©matiques : 4h/semaine, s√©ances de 60min
  ‚Üí 4 s√©ances par semaine
- EPS : 2h/semaine, s√©ances de 120min  
  ‚Üí 1 s√©ance par semaine
```

### Cr√©ation des cours

```dart
Pour chaque classe:
  Pour chaque mati√®re:
    Pour i de 1 √† nombreSeances:
      Cr√©er un cours(classe, mati√®re, professeur)
```

## üéØ √âtape 2 : Tri par priorit√©

Le tri est **crucial** pour la qualit√© du r√©sultat final.

### Formule de priorit√©

```dart
priorit√© = (salleSp√©ciale ? 50 : 0) 
         + (nombre_mati√®res_prof √ó 10)
         + (volume_horaire √ó 2)
```

### Exemples de priorit√©

| Cours | Salle sp√©. | Prof multi-mat. | Volume | Score | Rang |
|-------|------------|-----------------|--------|-------|------|
| EPS 6√®meA | ‚úÖ 50 | 1 mat. = 10 | 2h = 4 | **64** | 1 |
| Maths 6√®meA | ‚ùå 0 | 3 mat. = 30 | 4h = 8 | **38** | 2 |
| Anglais 6√®meB | ‚ùå 0 | 1 mat. = 10 | 3h = 6 | **16** | 3 |

**Logique** : On place d'abord les cours les plus contraints (EPS n√©cessite gymnase, professeur tr√®s demand√©).

## üé≤ √âtape 3 : Placement s√©quentiel

### 3.1 Trouver les cr√©neaux valides

Pour chaque cr√©neau possible, on v√©rifie :

```dart
bool estCreneauValide(cours, creneau):
  // Contrainte 1 : Disponibilit√© professeur
  SI prof.disponibilit√©s non vide:
    SI aucune disponibilit√© ne couvre ce cr√©neau:
      RETOURNER false
  
  // Contrainte 2 : Prof pas d√©j√† occup√©
  SI prof a d√©j√† un cours √† ce cr√©neau:
    RETOURNER false
  
  // Contrainte 3 : Classe pas d√©j√† occup√©e
  SI classe a d√©j√† un cours √† ce cr√©neau:
    RETOURNER false
  
  // Contrainte 4 : Dans les heures de cours
  SI cr√©neau.fin > heure_fin_√©cole:
    RETOURNER false
  
  RETOURNER true
```

### 3.2 √âvaluation de chaque cr√©neau

Chaque cr√©neau valide re√ßoit un **score d'optimisation** :

```dart
score = 0

// üåÖ Bonus : Mati√®re difficile le matin
SI matiere.difficult√© >= 4 ET cr√©neau < 12h00:
  score += 10

// üåÜ P√©nalit√© : Mati√®re difficile l'apr√®s-midi
SI matiere.difficult√© >= 4 ET cr√©neau > 14h00:
  score -= 15

// üï≥Ô∏è P√©nalit√© : Cr√©e un trou dans l'emploi du temps
SI existe trou entre 1h et 3h:
  score -= 20

// üöó Bonus : Prof d√©j√† pr√©sent ce jour
SI prof a d√©j√† cours ce jour:
  score += 5

// üîÑ Bonus : Alterne th√©orie/pratique
SI dernier_cours ‚â† m√™me_type:
  score += 8

RETOURNER score
```

### 3.3 Attribution de salle

```dart
Pour chaque salle:
  // V√©rifier capacit√©
  SI salle.capacit√© < classe.effectif:
    CONTINUER
  
  // V√©rifier disponibilit√©
  SI salle occup√©e √† ce cr√©neau:
    CONTINUER
  
  // V√©rifier type (pour mati√®res sp√©ciales)
  SI matiere.necessiteSalleSp√©ciale:
    SI salle.type ne correspond pas:
      CONTINUER
  
  RETOURNER salle
```

## üìà √âtape 4 : √âvaluation globale

### Score final

```dart
score = 0

// Taux de placement (0-1000 points)
score += (cours_plac√©s / cours_total) √ó 1000

// √âquilibre journalier (-‚àû √† 0 points)
Pour chaque classe:
  heuresParJour = [lun:6h, mar:5h, mer:7h, jeu:6h, ven:5h]
  √©cartType = calculer(heuresParJour)
  score -= √©cartType √ó 0.5

RETOURNER score
```

### Interpr√©tation du score

| Score | Qualit√© | Interpr√©tation |
|-------|---------|----------------|
| > 950 | Excellent | Tous les cours plac√©s, bien optimis√© |
| 800-950 | Bon | Quelques compromis, acceptable |
| 600-800 | Moyen | Plusieurs probl√®mes d'optimisation |
| < 600 | Faible | Beaucoup de cours non plac√©s |

## üéì Exemples concrets

### Exemple 1 : Placement r√©ussi

**Contexte :**
- Maths 6√®meA √† placer
- Lundi 8h-9h disponible
- Prof dispo, salle 101 libre

**Calcul du score :**
```
Score base = 0
+ Mati√®re difficile le matin = +10
+ Prof n'a pas encore de cours ce jour = 0
= Score final : 10 (bon cr√©neau)
```

**R√©sultat :** ‚úÖ Cours plac√© √† Lundi 8h-9h, Salle 101

### Exemple 2 : Conflit r√©solu

**Contexte :**
- EPS 6√®meA √† placer (2h)
- Seul le gymnase convient
- Gymnase libre uniquement Lundi 14h-16h

**Calcul :**
```
Score base = 0
+ Mati√®re peu difficile l'apr√®s-midi = 0
+ Pas de trou cr√©√© = 0
+ Seule option possible = placement obligatoire
= Score final : 0 (acceptable)
```

**R√©sultat :** ‚úÖ Cours plac√© malgr√© l'apr√®s-midi (pas le choix)

### Exemple 3 : Optimisation trous

**Contexte :**
- Anglais 6√®meA √† placer
- Cr√©neaux possibles :
  - Mardi 10h (entre Maths 8h et Fran√ßais 13h) ‚ùå cr√©e trou
  - Mardi 11h (juste avant Fran√ßais 13h) ‚ùå cr√©e trou  
  - Mercredi 9h (apr√®s Maths 8h) ‚úÖ pas de trou

**Scores :**
```
Mardi 10h : 0 - 20 (trou) = -20
Mardi 11h : 0 - 20 (trou) = -20
Mercredi 9h : 0 + 0 = 0
```

**R√©sultat :** ‚úÖ Mercredi 9h choisi (meilleur score)

## üöÄ Am√©liorations possibles

### 1. Algorithme g√©n√©tique

**Principe :** Faire √©voluer une population de solutions.

```dart
1. G√©n√©rer 100 emplois du temps al√©atoires
2. √âvaluer chacun (fitness)
3. S√©lectionner les 20 meilleurs
4. Croiser (parents ‚Üí enfants)
5. Muter l√©g√®rement (5% de changements)
6. R√©p√©ter jusqu'√† convergence
```

**Avantages :**
- Explore l'espace des solutions
- √âvite les minima locaux
- Meilleure qualit√© finale

**Inconv√©nients :**
- Plus lent (30s-2min)
- Plus complexe √† impl√©menter

### 2. Programmation par contraintes (CSP)

**Principe :** D√©crire le probl√®me comme un syst√®me de contraintes.

```dart
Variables : cours[i].cr√©neau
Domaines : tous les cr√©neaux possibles
Contraintes :
  - AllDifferent(cours_m√™me_prof)
  - AllDifferent(cours_m√™me_classe)
  - AllDifferent(cours_m√™me_salle)
  - VolumeHoraire(mati√®re, min, max)
```

**Outil recommand√© :** OR-Tools de Google

**Avantages :**
- Solution optimale garantie
- G√®re contraintes complexes
- Tr√®s performant

**Inconv√©nients :**
- D√©pendance externe
- Courbe d'apprentissage

### 3. Recuit simul√© (Simulated Annealing)

**Principe :** Accepter des solutions pires au d√©but, puis converger.

```dart
temp√©rature = 1000
TANT QUE temp√©rature > 0.1:
  nouveau = modifier_solution(actuel)
  
  SI score(nouveau) > score(actuel):
    actuel = nouveau
  SINON SI random() < exp((delta / temp√©rature)):
    actuel = nouveau  // Accepter quand m√™me
  
  temp√©rature *= 0.95  // Refroidissement
```

**Avantages :**
- √âvite blocages
- Rapide et efficace
- Facile √† impl√©menter

### 4. Backtracking intelligent

**Am√©lioration de l'algo actuel :**

```dart
fonction placer_cours_avec_backtracking(cours, profondeur):
  SI profondeur > MAX_PROFONDEUR:
    RETOURNER √©chec
  
  cr√©neaux = trouver_cr√©neaux_valides(cours)
  
  POUR chaque cr√©neau DANS cr√©neaux:
    placer(cours, cr√©neau)
    
    SI peut_continuer():
      r√©sultat = placer_cours_suivants()
      SI r√©sultat == succ√®s:
        RETOURNER succ√®s
    
    retirer(cours, cr√©neau)  // Backtrack
  
  RETOURNER √©chec
```

### 5. Heuristiques avanc√©es

#### a) Forward Checking
```dart
// Avant de placer un cours, v√©rifier que les cours suivants
// auront encore des cr√©neaux disponibles
```

#### b) MRV (Minimum Remaining Values)
```dart
// Placer en priorit√© les cours avec le moins de cr√©neaux possibles
```

#### c) Degree Heuristic
```dart
// Placer en priorit√© les cours qui contraignent le plus d'autres cours
```

## üíª Code d'am√©lioration : Algorithme g√©n√©tique

```dart
class GeneticTimetableGenerator {
  final int populationSize = 100;
  final int generations = 500;
  final double mutationRate = 0.05;
  final double crossoverRate = 0.7;

  Future<EmploiDuTemps> generer() async {
    // 1. Population initiale
    List<EmploiDuTemps> population = _genererPopulationInitiale();
    
    for (int gen = 0; gen < generations; gen++) {
      // 2. √âvaluation
      population.sort((a, b) => b.score.compareTo(a.score));
      
      // 3. √âlitisme (garder les 10% meilleurs)
      int eliteSize = (populationSize * 0.1).toInt();
      List<EmploiDuTemps> newPopulation = population.sublist(0, eliteSize);
      
      // 4. Croisement
      while (newPopulation.length < populationSize) {
        EmploiDuTemps parent1 = _selection(population);
        EmploiDuTemps parent2 = _selection(population);
        
        EmploiDuTemps enfant = _croisement(parent1, parent2);
        
        // 5. Mutation
        if (Random().nextDouble() < mutationRate) {
          enfant = _mutation(enfant);
        }
        
        newPopulation.add(enfant);
      }
      
      population = newPopulation;
      
      // Afficher progression
      if (gen % 50 == 0) {
        print('G√©n√©ration $gen - Meilleur score: ${population[0].score}');
      }
    }
    
    return population[0];  // Meilleur individu
  }
  
  EmploiDuTemps _croisement(EmploiDuTemps p1, EmploiDuTemps p2) {
    // Prendre 50% des cours de chaque parent
    List<Cours> nouveauxCours = [];
    
    for (int i = 0; i < p1.cours.length; i++) {
      if (Random().nextBool()) {
        nouveauxCours.add(p1.cours[i]);
      } else {
        nouveauxCours.add(p2.cours[i]);
      }
    }
    
    return EmploiDuTemps(
      id: generateId(),
      cours: _resoudreConflits(nouveauxCours),
      score: 0,
    );
  }
  
  EmploiDuTemps _mutation(EmploiDuTemps emploi) {
    // D√©placer al√©atoirement 5% des cours
    List<Cours> cours = List.from(emploi.cours);
    int nbMutations = (cours.length * 0.05).toInt();
    
    for (int i = 0; i < nbMutations; i++) {
      int index = Random().nextInt(cours.length);
      cours[index] = _deplacerCours(cours[index]);
    }
    
    return emploi.copyWith(cours: cours);
  }
}
```

## üìä Comparaison des approches

| Algorithme | Vitesse | Qualit√© | Complexit√© | Recommand√© pour |
|------------|---------|---------|------------|-----------------|
| Glouton | ‚ö°‚ö°‚ö° | ‚≠ê‚≠ê‚≠ê | üü¢ Simple | Petits √©tablissements |
| G√©n√©tique | ‚ö°‚ö° | ‚≠ê‚≠ê‚≠ê‚≠ê | üü° Moyen | Qualit√© importante |
| CSP | ‚ö°‚ö°‚ö° | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | üî¥ Complexe | Grands √©tablissements |
| Recuit simul√© | ‚ö°‚ö°‚ö° | ‚≠ê‚≠ê‚≠ê‚≠ê | üü° Moyen | Bon compromis |

## üéØ Recommandations

### Pour un √©tablissement de < 10 classes
‚Üí **Algorithme glouton actuel** (suffisant, rapide)

### Pour un √©tablissement de 10-30 classes
‚Üí **Algorithme g√©n√©tique** (meilleur qualit√©/complexit√©)

### Pour un √©tablissement de > 30 classes
‚Üí **CSP avec OR-Tools** (seul capable de g√©rer la complexit√©)

### Pour un prototype/MVP
‚Üí **Glouton + am√©liorations heuristiques** (code fourni)

## üìù Conclusion

L'algorithme fourni est un **excellent point de d√©part** qui :
- ‚úÖ Fonctionne imm√©diatement
- ‚úÖ Donne des r√©sultats acceptables (> 80% des cas)
- ‚úÖ Est facile √† comprendre et modifier
- ‚úÖ Peut √™tre am√©lior√© progressivement

Pour la production, envisagez :
1. **Court terme** : Affiner les poids et ajouter des heuristiques
2. **Moyen terme** : Impl√©menter le backtracking intelligent
3. **Long terme** : Migrer vers algorithme g√©n√©tique ou CSP